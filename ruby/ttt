#!/usr/bin/env ruby 

# Represents the state of a single game, including the board, the current player,
# and the winner, if any.
#
class Game

  attr_accessor :current_player
  attr_accessor :board
  attr_accessor :state

  def initialize(first_player = Player.new('X','O'))
    @current_player = first_player
    @board = Board.new
    @state = :continue
  end

  # Make a move for the current player. 
  def move(space)
    @board.move(current_player, space)
    @state = 
      if @board.winning?
        :win
      elsif @board.full?
        :draw
      else
        self.current_player = current_player.opponent
        :continue
      end
  rescue InvalidSpaceException
    :continue
  end

  def to_s
    "\n#{@board.to_s}\n\n" +
      case state
      when :win
        "#{current_player} Wins!\n"
      when :draw
        "It's a Draw!\n"
      when :continue
        "Select a square, #{current_player}: "
      end
  end

  def self.main
    game = Game.new

    while game.state == :continue
      print game
      game.move(gets.to_i)
    end

    print game
  end


end

# Players
class Player

  attr_reader :opponent

  def initialize(me, opponent)
    @me = me
    if self.class === opponent
      @opponent = opponent
    else
      @opponent = self.class.new(opponent, self)
    end
  end

  def to_s
    @me.to_s
  end

  def ==(other)
    @me == other.instance_variable_get(:@me)
  end

end

class Space

  attr_reader :player, :number

  def initialize(number)
    @number = number
  end

  def place(player)
    raise InvalidSpaceException if occupied?
    @player = player
  end

  def occupied?
    @player != nil
  end

  def ==(other)
    @player == other.instance_variable_get(:@player)
  end

  def to_s
    if occupied?
      " #{@player} "
    else
      "(#{@number})"
    end
  end
end

class InvalidSpaceException < Exception; end

class Board

  def initialize
    @board = default_board
    @slices = make_slices
  end

  def move(player, desired_space)
    space(desired_space).place(player)
  end

  def winning?
    @slices.detect { |s| s.winning? }
  end

  def full?
    @board.map { |s| s.occupied? }.reduce(:&)
  end

  def to_s
    rows.map do |row|
      row.join("|")
    end.join("\n---+---+---\n")
  end

  private

  def default_board
    (1..9).map { |i| Space.new(i) }
  end

  def space(n)
    raise InvalidSpaceException if n > @board.size  || n < 1
    @board[n-1]
  end

  def make_slices
    [ slice(1,2,3), slice(4,5,6), slice(7,8,9),
      slice(1,4,7), slice(2,5,8), slice(3,6,9),
      slice(1,5,9), slice(7,5,3) ]
  end

  def slice(i,j,k)
    Slice.new(space(i),space(j),space(k))
  end

  def rows 
    [@board[0,3], @board[3,3], @board[6,3]]
  end

end

# Represents a 3-in-a-row subset of the spaces on the board
class Slice
  def initialize(space1, space2, space3)
    @space1 = space1
    @space2 = space2
    @space3 = space3
  end

  def winning?
    @space1 == @space2 && @space2 == @space3 && @space1.player
  end

end

Game.main

# vim: ts=2 sw=2 et
